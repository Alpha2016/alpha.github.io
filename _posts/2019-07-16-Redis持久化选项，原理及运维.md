---
layout:     post
title:      Redis 持久化选项，原理及运维
subtitle:   Redis 持久化选项，原理及运维
date:       2019-07-16
author:     he xiaodong
header-img: img/default-post-bg.jpg
catalog: true
tags:
    - redis
    - aof
    - rdb
    - 持久化
---

Redis提供了两种持久化选项，分别是[RDB](http://redis.io/topics/persistence#snapshotting)和[AOF](http://redis.io/topics/persistence#snapshotting)。

默认情况下60秒刷新到 disk 一次[save 60 10000 当有1w条keys数据被改变时]，Redis 的数据集保存在叫 dump.rdb 一个二进制文件，这种策略被称为快照。

也可以手动调用Save或BGSAVE命令的：
`/usr/local/bin/redis-cli-h 127.0.0.1 -p 6379 -a pwd bgsave`

快照易恢复，文件也小，但是如果遇到宕机等情况的时候快照的数据可能会不完整。此时可能需要启用另一种持久化方式AOF，在配置文件中打开[appendonly yes]。

AOF刷新日志到disk的规则：
appendfsync always #always 表示每次有写操作都进行同步，非常慢，非常安全。
appendfsync everysec #everysec表示对写操作进行累积，每秒同步一次
官方的建议的 everysec，安全，就是速度不够快，如果是机器出现问题可能会丢失1秒的数据。

也可以手动执行 `bgrewriteaof` 进行AOF备份：

`/usr/local/bin/redis-cli-h 127.0.0.1 -p 6379 -a pwd bgrewriteaof`

我们现在的做法是一主(Master)多从(Slave)，主库不开启AOF持久化，只是每天备份一下RDB[官方给的建议是每小时备份RDB文件，看你的策略了]，而在从库上开启AOF备份，并且会用脚本将相应的备份文件推送到备份服务器。
当Redis服务器挂掉时，重启时将按照以下优先级恢复数据到内存：

- 如果只配置AOF,重启时加载AOF文件恢复数据；
- 如果同时配置了RBD和AOF,启动是只加载AOF文件恢复数据;
- 如果只配置RBD,启动是讲加载dump文件恢复数据。

**恢复时需要注意，要是主库挂了不能直接重启主库，否则会直接覆盖掉从库的AOF文件，一定要确保要恢复的文件都正确才能启动，否则会冲掉原来的文件。**

参考链接：<https://blog.csdn.net/subuser/article/details/8157178>


**RDB备份原理**：redis 会 fork 出一个子进程，子进程来处理所有的保存工作，父进程则不需要进行任何I/O操作，子进程做数据持久化，它不会修改现有的内存数据结构，它只是对数据结构进行遍历读取，然后序列化写到磁盘中。但是父进程不一样，它必须持续服务客户端请求，然后对内存数据结构进行不间断的修改。这个时候就会使用操作系统的 COW 机制来进行数据段页面的分离。数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复制一份分离出来，然后对这个复制的页面进行修改。这时子进程相应的页面是没有变化的，还是进程产生时那一瞬间的数据。 随着父进程修改操作的持续进行，越来越多的共享页面被分离出来，内存就会持续增长。但是也不会超过原有数据内存的 2 倍大小。另外一个 Redis 实例里冷数据占的比例往往是比较高的，所以很少会出现所有的页面都会被分离，被分离的往往只有其中一部分页面。每个页面的大小只有 4K，一个 Redis 实例里面一般都会有成千上万的页面。

子进程因为数据没有变化，它能看到的内存里的数据在进程产生的一瞬间就凝固了，再也不会改变，这也是为什么 Redis 的持久化叫「快照」的原因。接下来子进程就可以非常安心的遍历数据了进行序列化写磁盘了。

**RBD优点：**

1.RDB是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。

2.RDB非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。

3.RDB可以最大化Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。

4.RDB在恢复大数据集时的速度比 AOF 的恢复速度要快。
 
**RDB的缺点：**

1.如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。

2.每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。在数据集比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端；如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。


**AOF备份原理：**

AOF日志存储的是Redis 服务器的顺序指令序列，AOF 日志只记录对内存进行修改的指令记录。 假设 AOF 日志记录了自 Redis 实例创建以来所有的修改性指令序列，那么就可以通过对一个空的 Redis 实例顺序执行所有的指令，也就是「重放」，来恢复 Redis 当前实例的内存数据结构的状态。 Redis 会在收到客户端修改指令后，进行参数校验进行逻辑处理后，如果没问题，就立即将该指令文本存储到 AOF 日志中，也就是先执行指令才将日志存盘。

为了解决 AOF 文件越来越大的问题，**用户可以向 Redis 发送 BGREWRITEAOF命令，这个命令会移除 AOF 文件中冗余的命令来重写 AOF 文件，使 AOF 文件的体积变得尽可能地小。**
BGREWRITEAOF 的工作原理和快照持久化命令 BGSAVE 的工作原理类似，Redis 会创建一个子进程来负责对 AOF 文件进行重写。

值得注意的是，进行 AOF 文件重写时，如果原来的 AOF 文件体积已经非常大，那么重写 AOF 并删除旧 AOF 文件的过程将会对 Redis 的性能造成较大的影响。

为此，Redis 提供 `auto-aof-rewrite-percentage` 和`auto-aof-rewrite-min-size` 两个配置选项来对 AOF 重写进行配置。`auto-aof-rewrite-percentage` 和 `auto-aof-rewrite-min-size` 两个配置选项的含义可以参考 `redis.conf` 配置中的详细说明，具体来说，`auto-aof-rewrite-percentage` 配置当 AOF 文件需要比旧 AOF 文件增大多少时才进行 AOF 重写，而 `auto-aof-rewrite-min-size` 则配置当 AOF 文件需要达到多大体积时才进行 AOF 重写。只有这两个配置的条件都达到时，才会进行 AOF 重写。

**AOF的优点：**

使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。

AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。

Redis可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。

AOF文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 [FLUSHALL](http://redisdoc.com/server/flushall.html#flushall) 命令，但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 [FLUSHALL](http://redisdoc.com/server/flushall.html#flushall) 命令，并重启 Redis ， 就可以将数据集恢复到 [FLUSHALL](http://redisdoc.com/server/flushall.html#flushall) 执行之前的状态。

**AOF的缺点：**

对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。

根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高，而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。

AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。（举个例子，阻塞命令 [BRPOPLPUSH](http://redisdoc.com/list/brpoplpush.html#brpoplpush) 就曾经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。

**运维：**

**快照需要遍历整个内存，这个会加重系统负担，aof 的 fsync 方式也会带来频繁的I/O 操作，带来 I/O 负担**

所以通常 Redis 的主节点是不会进行持久化操作，**持久化操作主要在从节点进行。**从节点是备份节点，没有来自客户端请求的压力，它的操作系统资源往往比较充沛。但是如果出现网络分区，从节点长期连不上主节点，就会出现数据不一致的问题，特别是在网络分区出现的情况下又不小心主节点宕机了，那么数据就会丢失，所以在生产环境要做好实时监控工作，保证网络畅通或者能快速修复。另外还应该再增加一个从节点以降低网络分区的概率，只要有一个从节点数据同步正常，数据也就不会轻易丢失。

**参考链接：[持久化](http://redisdoc.com/topic/persistence.html) 官方文档是最好的，部分参考来自掘金付费小册，作者是老钱**


最后恰饭 [阿里云全系列产品/短信包特惠购买 中小企业上云最佳选择 阿里云内部优惠券](https://www.aliyun.com/minisite/goods?userCode=0amqgcs9)