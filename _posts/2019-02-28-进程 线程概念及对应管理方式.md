---
layout:     post
title:      进程 线程概念及对应管理方式
subtitle:   进程 线程概念及对应管理方式
date:       2019-02-28
author:     he xiaodong
header-img: img/default-post-bg.jpg
catalog: true
tags:
    - 进程
    - 线程
    - 进程控制块
    - 线程池
    - Unix
---

> 主要是来自维基百科的基础概念，当作笔记

**进程的定义：**

进程是正在运行的程序的实例。
进程需要一些资源才能完成工作，如CPU使用时间、存储器、文件以及I/O设备，且为依序逐一进行，也就是每个CPU核心任何时间内仅能运行一项进程。

**进程包含下列内容/数据：**

1. 那个程序的可执行机器代码的一个在存储器的映像。
2. 分配到的存储器（通常是虚拟的一个存储器区域）。存储器的内容包括可执行代码、特定于进程的数据（输入、输出）、调用堆栈、堆栈（用于保存运行时运输中途产生的数据）。
3. 分配给该进程的资源的操作系统描述符，诸如文件描述符（Unix术语）或文件句柄（Windows）、数据源和数据终端。
4. 安全特性，诸如进程拥有者和进程的权限集（可以容许的操作）。
5. 处理器状态（内文），诸如寄存器内容、物理存储器定址等。当进程正在运行时，状态通常存储在寄存器，其他情况在存储器。

**进程的几种状态**

进程在运行时，状态（state）会改变。所谓状态，就是指进程当前的动作：

创建（new）：进程新创建中。

运行（running）：正在运行。

等待（waiting）：等待某事发生，例如等待用户输入完成。亦称“阻塞”（blocked）

就绪（ready）：排班中，等待CPU。

结束（terminated）：完成运行。

各状态名称可能随不同操作系统而相异；对于单CPU系统（UP），任何时间可能有多个进程为等待、就绪，但必定仅有一个进程在运行。

**进程的管理方式：**

进程由进程控制块管理（Process Control Block），PCB是操作系统核心中一种数据结构，主要表示进程状态。

虽各实际情况不尽相同，PCB通常记载进程之相关信息，包括：

•	进程状态：可以是new、ready、running、waiting或 blocked等。

•	程序计数器：接着要运行的指令地址。

•	CPU寄存器：如累加器、变址寄存器、堆栈指针以及一般用途寄存器、状况代码等，主要用途在于中断时暂时存储数据，以便稍后继续利用；其数量及类别因计算机体系结构有所差异。

•	CPU排班法：优先级、排班队列等指针以及其他参数。

•	存储器管理：如标签页表等。

•	会计信息：如CPU与实际时间之使用数量、时限、账号、工作或进程号码。

•	输入输出状态：配置进程使用I/O设备，如磁带机。



**线程的定义：**
单个进程中执行中每个任务就是一个线程。线程是进程中执行运算的最小单位。被包含在进程之中，是进程中的实际运作单位。**一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。**同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。

在多核或多CPU，或支持Hyper-threading的CPU上使用多线程程序设计的好处是显而易见，即提高了程序的执行吞吐率。在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责I/O处理、人机交互而常被阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，从而提高了程序的执行效率。

**线程的管理：**
由线程池（thread pool）统一管理，线程池：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。 例如，线程数一般取cpu数量+2比较合适，线程数过多会导致额外的线程切换开销。

任务调度以执行线程的常见方法是使用同步队列，称作任务队列。池中的线程等待队列中的任务，并把执行完的任务放入完成队列中。

线程池模式一般分为两种：HS/HA半同步/半异步模式、L/F领导者与跟随者模式。

•	半同步/半异步模式又称为生产者消费者模式，是比较常见的实现方式，比较简单。分为同步层、队列层、异步层三层。同步层的主线程处理工作任务并存入工作队列，工作线程从工作队列取出任务进行处理，如果工作队列为空，则取不到任务的工作线程进入挂起状态。由于线程间有数据通信，因此不适于大数据量交换的场合。

•	领导者跟随者模式，在线程池中的线程可处在3种状态之一：领导者leader、追随者follower或工作者processor。任何时刻线程池只有一个领导者线程。事件到达时，领导者线程负责消息分离，并从处于追随者线程中选出一个来当继任领导者，然后将自身设置为工作者状态去处置该事件。处理完毕后工作者线程将自身的状态置为追随者。这一模式实现复杂，但避免了线程间交换任务数据，提高了CPU cache相似性。

参考链接：

1. [进程](https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B "进程 维基百科")
2. [线程](https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B "线程 维基百科") 
3. [进程控制块](https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%A1%A8 "进程控制块 维基百科")
4. [线程池](https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E6%B1%A0 "线程池 维基百科") 
5. [阮一峰文章](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html "阮一峰 进程和线程的关系") 
